{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _transmitter = require('transmitter');\n\nvar _transmitter2 = _interopRequireDefault(_transmitter);\n\nvar _functions = require('../functions');\n\nvar fn = _interopRequireWildcard(_functions);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj['default'] = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar StoreMixin = {\n  waitFor: function () {\n    function waitFor() {\n      for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {\n        sources[_key] = arguments[_key];\n      }\n\n      if (!sources.length) {\n        throw new ReferenceError('Dispatch tokens not provided');\n      }\n\n      var sourcesArray = sources;\n\n      if (sources.length === 1) {\n        sourcesArray = Array.isArray(sources[0]) ? sources[0] : sources;\n      }\n\n      var tokens = sourcesArray.map(function (source) {\n        return source.dispatchToken || source;\n      });\n      this.dispatcher.waitFor(tokens);\n    }\n\n    return waitFor;\n  }(),\n  exportAsync: function () {\n    function exportAsync(asyncMethods) {\n      this.registerAsync(asyncMethods);\n    }\n\n    return exportAsync;\n  }(),\n  registerAsync: function () {\n    function registerAsync(asyncDef) {\n      var _this = this;\n\n      var loadCounter = 0;\n      var asyncMethods = fn.isFunction(asyncDef) ? asyncDef(this.alt) : asyncDef;\n      var toExport = Object.keys(asyncMethods).reduce(function (publicMethods, methodName) {\n        var desc = asyncMethods[methodName];\n        var spec = fn.isFunction(desc) ? desc(_this) : desc;\n        var validHandlers = ['success', 'error', 'loading'];\n        validHandlers.forEach(function (handler) {\n          if (spec[handler] && !spec[handler].id) {\n            throw new Error(String(handler) + ' handler must be an action function');\n          }\n        });\n\n        publicMethods[methodName] = function () {\n          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            args[_key2] = arguments[_key2];\n          }\n\n          var state = _this.getInstance().getState();\n\n          var value = spec.local && spec.local.apply(spec, [state].concat(args));\n          var shouldFetch = spec.shouldFetch ? spec.shouldFetch.apply(spec, [state].concat(args))\n          /*eslint-disable*/\n          : value == null;\n          /*eslint-enable*/\n\n          var intercept = spec.interceptResponse || function (x) {\n            return x;\n          };\n\n          var makeActionHandler = function () {\n            function makeActionHandler(action, isError) {\n              return function (x) {\n                var fire = function () {\n                  function fire() {\n                    loadCounter -= 1;\n                    action(intercept(x, action, args));\n                    if (isError) throw x;\n                    return x;\n                  }\n\n                  return fire;\n                }();\n\n                return _this.alt.trapAsync ? function () {\n                  return fire();\n                } : fire();\n              };\n            }\n\n            return makeActionHandler;\n          }(); // if we don't have it in cache then fetch it\n\n\n          if (shouldFetch) {\n            loadCounter += 1;\n            /* istanbul ignore else */\n\n            if (spec.loading) spec.loading(intercept(null, spec.loading, args));\n            return spec.remote.apply(spec, [state].concat(args)).then(makeActionHandler(spec.success), makeActionHandler(spec.error, 1));\n          } // otherwise emit the change now\n\n\n          _this.emitChange();\n\n          return value;\n        };\n\n        return publicMethods;\n      }, {});\n      this.exportPublicMethods(toExport);\n      this.exportPublicMethods({\n        isLoading: function () {\n          function isLoading() {\n            return loadCounter > 0;\n          }\n\n          return isLoading;\n        }()\n      });\n    }\n\n    return registerAsync;\n  }(),\n  exportPublicMethods: function () {\n    function exportPublicMethods(methods) {\n      var _this2 = this;\n\n      fn.eachObject(function (methodName, value) {\n        if (!fn.isFunction(value)) {\n          throw new TypeError('exportPublicMethods expects a function');\n        }\n\n        _this2.publicMethods[methodName] = value;\n      }, [methods]);\n    }\n\n    return exportPublicMethods;\n  }(),\n  emitChange: function () {\n    function emitChange() {\n      this.getInstance().emitChange();\n    }\n\n    return emitChange;\n  }(),\n  on: function () {\n    function on(lifecycleEvent, handler) {\n      if (lifecycleEvent === 'error') this.handlesOwnErrors = true;\n      var bus = this.lifecycleEvents[lifecycleEvent] || (0, _transmitter2['default'])();\n      this.lifecycleEvents[lifecycleEvent] = bus;\n      return bus.subscribe(handler.bind(this));\n    }\n\n    return on;\n  }(),\n  bindAction: function () {\n    function bindAction(symbol, handler) {\n      if (!symbol) {\n        throw new ReferenceError('Invalid action reference passed in');\n      }\n\n      if (!fn.isFunction(handler)) {\n        throw new TypeError('bindAction expects a function');\n      } // You can pass in the constant or the function itself\n\n\n      var key = symbol.id ? symbol.id : symbol;\n      this.actionListeners[key] = this.actionListeners[key] || [];\n      this.actionListeners[key].push(handler.bind(this));\n      this.boundListeners.push(key);\n    }\n\n    return bindAction;\n  }(),\n  bindActions: function () {\n    function bindActions(actions) {\n      var _this3 = this;\n\n      fn.eachObject(function (action, symbol) {\n        var matchFirstCharacter = /./;\n        var assumedEventHandler = action.replace(matchFirstCharacter, function (x) {\n          return 'on' + String(x[0].toUpperCase());\n        });\n\n        if (_this3[action] && _this3[assumedEventHandler]) {\n          // If you have both action and onAction\n          throw new ReferenceError('You have multiple action handlers bound to an action: ' + (String(action) + ' and ' + String(assumedEventHandler)));\n        }\n\n        var handler = _this3[action] || _this3[assumedEventHandler];\n\n        if (handler) {\n          _this3.bindAction(symbol, handler);\n        }\n      }, [actions]);\n    }\n\n    return bindActions;\n  }(),\n  bindListeners: function () {\n    function bindListeners(obj) {\n      var _this4 = this;\n\n      fn.eachObject(function (methodName, symbol) {\n        var listener = _this4[methodName];\n\n        if (!listener) {\n          throw new ReferenceError(String(methodName) + ' defined but does not exist in ' + String(_this4.displayName));\n        }\n\n        if (Array.isArray(symbol)) {\n          symbol.forEach(function (action) {\n            _this4.bindAction(action, listener);\n          });\n        } else {\n          _this4.bindAction(symbol, listener);\n        }\n      }, [obj]);\n    }\n\n    return bindListeners;\n  }()\n};\nexports['default'] = StoreMixin;\nmodule.exports = exports['default'];","map":{"version":3,"sources":["D:/Projects/W_e_e_b/my-app/node_modules/alt/lib/store/StoreMixin.js"],"names":["Object","defineProperty","exports","value","_transmitter","require","_transmitter2","_interopRequireDefault","_functions","fn","_interopRequireWildcard","obj","__esModule","newObj","key","prototype","hasOwnProperty","call","StoreMixin","waitFor","_len","arguments","length","sources","Array","_key","ReferenceError","sourcesArray","isArray","tokens","map","source","dispatchToken","dispatcher","exportAsync","asyncMethods","registerAsync","asyncDef","_this","loadCounter","isFunction","alt","toExport","keys","reduce","publicMethods","methodName","desc","spec","validHandlers","forEach","handler","id","Error","String","_len2","args","_key2","state","getInstance","getState","local","apply","concat","shouldFetch","intercept","interceptResponse","x","makeActionHandler","action","isError","fire","trapAsync","loading","remote","then","success","error","emitChange","exportPublicMethods","isLoading","methods","_this2","eachObject","TypeError","on","lifecycleEvent","handlesOwnErrors","bus","lifecycleEvents","subscribe","bind","bindAction","symbol","actionListeners","push","boundListeners","bindActions","actions","_this3","matchFirstCharacter","assumedEventHandler","replace","toUpperCase","bindListeners","_this4","listener","displayName","module"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _transmitter = require('transmitter');\n\nvar _transmitter2 = _interopRequireDefault(_transmitter);\n\nvar _functions = require('../functions');\n\nvar fn = _interopRequireWildcard(_functions);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar StoreMixin = {\n  waitFor: function () {\n    function waitFor() {\n      for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {\n        sources[_key] = arguments[_key];\n      }\n\n      if (!sources.length) {\n        throw new ReferenceError('Dispatch tokens not provided');\n      }\n\n      var sourcesArray = sources;\n      if (sources.length === 1) {\n        sourcesArray = Array.isArray(sources[0]) ? sources[0] : sources;\n      }\n\n      var tokens = sourcesArray.map(function (source) {\n        return source.dispatchToken || source;\n      });\n\n      this.dispatcher.waitFor(tokens);\n    }\n\n    return waitFor;\n  }(),\n  exportAsync: function () {\n    function exportAsync(asyncMethods) {\n      this.registerAsync(asyncMethods);\n    }\n\n    return exportAsync;\n  }(),\n  registerAsync: function () {\n    function registerAsync(asyncDef) {\n      var _this = this;\n\n      var loadCounter = 0;\n\n      var asyncMethods = fn.isFunction(asyncDef) ? asyncDef(this.alt) : asyncDef;\n\n      var toExport = Object.keys(asyncMethods).reduce(function (publicMethods, methodName) {\n        var desc = asyncMethods[methodName];\n        var spec = fn.isFunction(desc) ? desc(_this) : desc;\n\n        var validHandlers = ['success', 'error', 'loading'];\n        validHandlers.forEach(function (handler) {\n          if (spec[handler] && !spec[handler].id) {\n            throw new Error(String(handler) + ' handler must be an action function');\n          }\n        });\n\n        publicMethods[methodName] = function () {\n          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            args[_key2] = arguments[_key2];\n          }\n\n          var state = _this.getInstance().getState();\n          var value = spec.local && spec.local.apply(spec, [state].concat(args));\n          var shouldFetch = spec.shouldFetch ? spec.shouldFetch.apply(spec, [state].concat(args))\n          /*eslint-disable*/\n          : value == null;\n          /*eslint-enable*/\n          var intercept = spec.interceptResponse || function (x) {\n            return x;\n          };\n\n          var makeActionHandler = function () {\n            function makeActionHandler(action, isError) {\n              return function (x) {\n                var fire = function () {\n                  function fire() {\n                    loadCounter -= 1;\n                    action(intercept(x, action, args));\n                    if (isError) throw x;\n                    return x;\n                  }\n\n                  return fire;\n                }();\n                return _this.alt.trapAsync ? function () {\n                  return fire();\n                } : fire();\n              };\n            }\n\n            return makeActionHandler;\n          }();\n\n          // if we don't have it in cache then fetch it\n          if (shouldFetch) {\n            loadCounter += 1;\n            /* istanbul ignore else */\n            if (spec.loading) spec.loading(intercept(null, spec.loading, args));\n            return spec.remote.apply(spec, [state].concat(args)).then(makeActionHandler(spec.success), makeActionHandler(spec.error, 1));\n          }\n\n          // otherwise emit the change now\n          _this.emitChange();\n          return value;\n        };\n\n        return publicMethods;\n      }, {});\n\n      this.exportPublicMethods(toExport);\n      this.exportPublicMethods({\n        isLoading: function () {\n          function isLoading() {\n            return loadCounter > 0;\n          }\n\n          return isLoading;\n        }()\n      });\n    }\n\n    return registerAsync;\n  }(),\n  exportPublicMethods: function () {\n    function exportPublicMethods(methods) {\n      var _this2 = this;\n\n      fn.eachObject(function (methodName, value) {\n        if (!fn.isFunction(value)) {\n          throw new TypeError('exportPublicMethods expects a function');\n        }\n\n        _this2.publicMethods[methodName] = value;\n      }, [methods]);\n    }\n\n    return exportPublicMethods;\n  }(),\n  emitChange: function () {\n    function emitChange() {\n      this.getInstance().emitChange();\n    }\n\n    return emitChange;\n  }(),\n  on: function () {\n    function on(lifecycleEvent, handler) {\n      if (lifecycleEvent === 'error') this.handlesOwnErrors = true;\n      var bus = this.lifecycleEvents[lifecycleEvent] || (0, _transmitter2['default'])();\n      this.lifecycleEvents[lifecycleEvent] = bus;\n      return bus.subscribe(handler.bind(this));\n    }\n\n    return on;\n  }(),\n  bindAction: function () {\n    function bindAction(symbol, handler) {\n      if (!symbol) {\n        throw new ReferenceError('Invalid action reference passed in');\n      }\n      if (!fn.isFunction(handler)) {\n        throw new TypeError('bindAction expects a function');\n      }\n\n      // You can pass in the constant or the function itself\n      var key = symbol.id ? symbol.id : symbol;\n      this.actionListeners[key] = this.actionListeners[key] || [];\n      this.actionListeners[key].push(handler.bind(this));\n      this.boundListeners.push(key);\n    }\n\n    return bindAction;\n  }(),\n  bindActions: function () {\n    function bindActions(actions) {\n      var _this3 = this;\n\n      fn.eachObject(function (action, symbol) {\n        var matchFirstCharacter = /./;\n        var assumedEventHandler = action.replace(matchFirstCharacter, function (x) {\n          return 'on' + String(x[0].toUpperCase());\n        });\n\n        if (_this3[action] && _this3[assumedEventHandler]) {\n          // If you have both action and onAction\n          throw new ReferenceError('You have multiple action handlers bound to an action: ' + (String(action) + ' and ' + String(assumedEventHandler)));\n        }\n\n        var handler = _this3[action] || _this3[assumedEventHandler];\n        if (handler) {\n          _this3.bindAction(symbol, handler);\n        }\n      }, [actions]);\n    }\n\n    return bindActions;\n  }(),\n  bindListeners: function () {\n    function bindListeners(obj) {\n      var _this4 = this;\n\n      fn.eachObject(function (methodName, symbol) {\n        var listener = _this4[methodName];\n\n        if (!listener) {\n          throw new ReferenceError(String(methodName) + ' defined but does not exist in ' + String(_this4.displayName));\n        }\n\n        if (Array.isArray(symbol)) {\n          symbol.forEach(function (action) {\n            _this4.bindAction(action, listener);\n          });\n        } else {\n          _this4.bindAction(symbol, listener);\n        }\n      }, [obj]);\n    }\n\n    return bindListeners;\n  }()\n};\n\nexports['default'] = StoreMixin;\nmodule.exports = exports['default'];"]},"metadata":{},"sourceType":"script"}